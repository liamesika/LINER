'use client';

import { useState } from 'react';
import { Target, ChevronDown, ChevronUp, AlertTriangle, Zap, Search, ListChecks, ShieldAlert, Rocket, BookOpen } from 'lucide-react';

// =============================================
// Types
// =============================================

interface HWData {
  number: number;
  title: string;
  topic: string;
  mindset: string[];
  goldenRules: string[];
  identification: { type: string; signals: string[] }[];
  strategies: { name: string; steps: string[] }[];
  traps: { trap: string; wrong: string; right: string }[];
  shortcuts: string[];
  cheatSheet: string[];
}

// =============================================
// ALL HOMEWORK DATA
// =============================================

const hwData: HWData[] = [
  // ══════════════════════════════════════════
  // HW 1 — Fields (שדות)
  // ══════════════════════════════════════════
  {
    number: 1,
    title: 'שדות',
    topic: 'fields',
    mindset: [
      'השיעורי בית הזה בודק הבנה של אקסיומות שדה — לא חישוב, אלא לוגיקה.',
      'הטעויות הנפוצות: לשכוח שאקסיומה אחת שנכשלת מספיקה כדי להפריך, ולהניח שמשהו "ברור" בלי להוכיח.',
      'גישה: כשמוכיחים — השתמש רק באקסיומות. כשמפריכים — דוגמה נגדית אחת מספיקה.',
    ],
    goldenRules: [
      'אם צריך להוכיח שקבוצה עם פעולות היא שדה — בדוק את כל 9 האקסיומות, אחת אחת.',
      'אם צריך להפריך — מספיק למצוא אקסיומה אחת שנכשלת + דוגמה נגדית.',
      'בשדה אין מחלקי אפס: a·b = 0 גורר a = 0 או b = 0.',
      'בשדה סופי (כמו Z_p) — חשבון מודולרי. הכל mod p.',
      'x² = x בשדה גורר x = 0 או x = 1 (כי x(x-1) = 0 ואין מחלקי אפס).',
      'ב-Z_n: הוא שדה אם ורק אם n ראשוני.',
      'כדי לבנות שדה עם 4 איברים — לא ניתן להשתמש ב-Z₄ (לא ראשוני). צריך מבנה אחר.',
      'חוק הצמצום: a + c = b + c גורר a = b. תקף בכל שדה.',
    ],
    identification: [
      {
        type: 'הוכח שמבנה הוא שדה',
        signals: [
          'נתון: קבוצה + שתי פעולות',
          'מילות מפתח: "הוכח כי זהו שדה", "בדוק אקסיומות"',
          'צריך: לעבור על כל 9 האקסיומות אחת אחת',
        ],
      },
      {
        type: 'הוכח שמבנה אינו שדה',
        signals: [
          'מילות מפתח: "הוכח כי אינו שדה", "הפרך"',
          'מספיק: למצוא אקסיומה אחת שנכשלת',
          'טיפ: בדוק קודם הפיכות כפלית ומחלקי אפס — שם בד"כ נכשל',
        ],
      },
      {
        type: 'בניית שדה סופי',
        signals: [
          '"בנה שדה עם n איברים"',
          'n חייב להיות חזקה של ראשוני',
          'צריך לבנות טבלאות חיבור וכפל',
        ],
      },
    ],
    strategies: [
      {
        name: 'הוכחת תכונה בשדה',
        steps: [
          'שלב 1: כתוב מה נתון ומה צריך להוכיח.',
          'שלב 2: השתמש רק באקסיומות שדה — אל תניח שום דבר נוסף.',
          'שלב 3: אם מגיעים ל-a·b = 0 — השתמש ב"אין מחלקי אפס".',
          'שלב 4: ודא שכל מעבר מוצדק על ידי אקסיומה ספציפית.',
        ],
      },
      {
        name: 'בניית שדה F₄',
        steps: [
          'שלב 1: הגדר F₄ = {0, 1, a, b}.',
          'שלב 2: בנה טבלת חיבור כך שכל שורה ועמודה הן תמורה.',
          'שלב 3: בנה טבלת כפל כך שלכל איבר ≠ 0 יש הופכי.',
          'שלב 4: ודא חילוקיות (distributivity).',
        ],
      },
    ],
    traps: [
      {
        trap: 'Z₄ הוא שדה כי יש בו 4 איברים',
        wrong: '4 איברים = שדה',
        right: 'Z₄ אינו שדה כי 2·2 = 0 (מחלקי אפס). 4 לא ראשוני.',
      },
      {
        trap: '"ברור" ש-x · 0 = 0',
        wrong: 'זה "טריוויאלי"',
        right: 'צריך הוכחה: x·0 = x·(0+0) = x·0 + x·0, ואז צמצום.',
      },
      {
        trap: 'חוק הצמצום בכפל',
        wrong: 'ab = ac גורר b = c',
        right: 'נכון רק אם a ≠ 0. בשדה: a ≠ 0 → a הפיך → b = c.',
      },
    ],
    shortcuts: [
      'Z_n שדה ⟺ n ראשוני — אין צורך לבדוק אקסיומות.',
      'x² = x → x = 0 או x = 1 — ישירות, בלי חישוב.',
      'אם מצאת מחלקי אפס → לא שדה. סוף.',
    ],
    cheatSheet: [
      'שדה = 9 אקסיומות + אין מחלקי אפס.',
      'Z_n שדה ⟺ n ראשוני.',
      'מחלקי אפס → לא שדה.',
      'x² = x → x ∈ {0, 1}.',
      'להפריך = דוגמה נגדית אחת.',
      'חוק צמצום בכפל דורש a ≠ 0.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 2 — Complex Numbers (מספרים מרוכבים)
  // ══════════════════════════════════════════
  {
    number: 2,
    title: 'מספרים מרוכבים ומבני שדה',
    topic: 'complex-numbers',
    mindset: [
      'שיעורי בית 2 בודק שליטה טכנית בחשבון מרוכבים + הבנה מבנית של שדות על R².',
      'הטעות הנפוצה: לטעות בסימן כשמכפילים מרוכבים, או לשכוח לצמד כשמחלקים.',
      'גישה: בחילוק — כפול בצמוד. בחזקות של i — מחזוריות של 4.',
    ],
    goldenRules: [
      'i² = -1. תמיד.',
      'חילוק: (a+bi)/(c+di) = כפל מונה ומכנה בצמוד (c-di).',
      'חזקות של i: i¹=i, i²=-1, i³=-i, i⁴=1. מחזור של 4.',
      'i^n — חשב n mod 4 וזהו.',
      'בבדיקת שדה על R² עם פעולות מותאמות: המפתח הוא הפיכות כפלית.',
      'מחלקי אפס ב-R²: אם (a,0)·(0,b) = (0,0) → מחלקי אפס → לא שדה.',
      'הצמוד: |z|² = z · z̄ = a² + b².',
    ],
    identification: [
      {
        type: 'חשבון מרוכבים',
        signals: [
          'ביטויים עם i, חיבור/כפל/חילוק/חזקות',
          '"מצא a,b ממשיים כך ש-z = a+bi"',
          'טיפ: תמיד פשט עד צורת a+bi',
        ],
      },
      {
        type: 'בדיקת שדה על R² עם פעולות חדשות',
        signals: [
          'הגדרה של + ו-· על R² שונה מהסטנדרטית',
          'צריך לבדוק כל אקסיומה עם הפעולות החדשות',
          'שים לב: הפעולות עלולות להיראות "כמו" מרוכבים אבל להיות שונות',
        ],
      },
    ],
    strategies: [
      {
        name: 'חילוק מספרים מרוכבים',
        steps: [
          'שלב 1: זהה מכנה c+di.',
          'שלב 2: כפול מונה ומכנה ב-c-di.',
          'שלב 3: מכנה הופך ל-c²+d².',
          'שלב 4: פשט מונה לצורת a+bi.',
        ],
      },
      {
        name: 'חזקה גבוהה של i',
        steps: [
          'שלב 1: חשב n mod 4.',
          'שלב 2: שאר 0 → i⁴=1. שאר 1 → i. שאר 2 → -1. שאר 3 → -i.',
          'שלב 3: סיום.',
        ],
      },
    ],
    traps: [
      {
        trap: 'שוכחים לכפול בצמוד בחילוק',
        wrong: '(1+i)/(1-i) = ... ישר לחלק',
        right: 'כפול ב-1+i / 1+i. מכנה = 1+1 = 2. מונה = (1+i)² = 2i. תוצאה: i.',
      },
      {
        trap: 'i² = 1',
        wrong: 'i² חיובי',
        right: 'i² = -1. תמיד.',
      },
      {
        trap: 'R² עם כפל רכיב-רכיב הוא שדה',
        wrong: '(a₁,a₂)·(b₁,b₂) = (a₁b₁, a₂b₂) → שדה',
        right: '(1,0)·(0,1) = (0,0) → מחלקי אפס → לא שדה!',
      },
    ],
    shortcuts: [
      'i^n: חשב n mod 4 — סיום.',
      '|z|² = a² + b² — בלי שורש.',
      'אם יש (a,0)·(0,b)=(0,0) עם a,b≠0 → לא שדה. סוף.',
    ],
    cheatSheet: [
      'i² = -1.',
      'חילוק = כפל בצמוד.',
      'i^n → n mod 4.',
      'R² עם כפל רכיב-רכיב → לא שדה (מחלקי אפס).',
      '|z|² = z·z̄.',
      'בדיקת שדה → תתחיל מהפיכות כפלית.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 3 — Systems & Gaussian Elimination
  // ══════════════════════════════════════════
  {
    number: 3,
    title: 'מערכות משוואות ודירוג',
    topic: 'systems-of-equations',
    mindset: [
      'שיעורי בית 3 בודק שליטה מלאה בדירוג גאוס ובפרשנות התוצאה.',
      'הטעות הנפוצה: לבצע דירוג נכון אבל לפרש לא נכון את מרחב הפתרונות.',
      'גישה: דרג → זהה עמודות ציר ועמודות חופשיות → כתוב פתרון.',
    ],
    goldenRules: [
      'שורת סתירה (0 0 ... 0 | c≠0) → אין פתרון. נקודה.',
      'מספר משתנים חופשיים = מספר עמודות - מספר עמודות ציר.',
      '0 משתנים חופשיים → פתרון יחיד.',
      '≥1 משתנים חופשיים → אינסוף פתרונות.',
      'מערכת הומוגנית (Ax=0) תמיד יש לה את הפתרון הטריוויאלי x=0.',
      'מערכת הומוגנית עם n משתנים ו-m < n משוואות → תמיד יש פתרון לא טריוויאלי.',
      'פתרון כללי = פתרון פרטי + פתרון הומוגני.',
      'בצורה מדורגת מצומצמת (RREF): כל עמודת ציר מכילה 1 ואפסים מעל ומתחת.',
    ],
    identification: [
      {
        type: 'פתור מערכת משוואות',
        signals: [
          'מערכת משוואות ליניאריות',
          '"פתור", "מצא את קבוצת הפתרונות"',
          'אלגוריתם: בנה [A|b] → דרג → פרש',
        ],
      },
      {
        type: 'בנה מערכת עם מספר פתרונות נתון',
        signals: [
          '"מצא מערכת עם פתרון יחיד / ללא פתרון / אינסוף"',
          'פתרון יחיד: מטריצה מרובעת עם דרגה מלאה',
          'אין: שורת סתירה',
          'אינסוף: עמודה חופשית',
        ],
      },
    ],
    strategies: [
      {
        name: 'פתרון מערכת — האלגוריתם',
        steps: [
          'שלב 1: בנה מטריצה מורחבת [A|b].',
          'שלב 2: דרג לצורה מדורגת (Echelon Form).',
          'שלב 3: בדוק שורת סתירה. אם יש → אין פתרון.',
          'שלב 4: זהה עמודות ציר (pivots) ועמודות חופשיות.',
          'שלב 5: משתנים חופשיים = פרמטרים חופשיים. כתוב פתרון.',
        ],
      },
      {
        name: 'בניית מערכת לפי דרישה',
        steps: [
          'שלב 1: פתרון יחיד — דרגה מלאה, מטריצה מרובעת.',
          'שלב 2: אין פתרון — הוסף שורת סתירה.',
          'שלב 3: אינסוף עם k חופשיים — דרגה = n - k.',
        ],
      },
    ],
    traps: [
      {
        trap: 'שורת אפסים = אין פתרון',
        wrong: 'שורת (0 0 0 | 0) = סתירה',
        right: 'שורת (0 0 0 | 0) = משוואה טריוויאלית 0=0, תמיד מתקיימת. לא סתירה!',
      },
      {
        trap: 'יותר משוואות ממשתנים → אין פתרון',
        wrong: 'מערכת 5×3 → בוודאי אין פתרון',
        right: 'לא בהכרח. משוואות יכולות להיות תלויות. בדוק דרגה!',
      },
      {
        trap: 'פחות משוואות ממשתנים → אינסוף',
        wrong: 'm < n → תמיד אינסוף',
        right: 'רק אם המערכת עקבית! אם יש שורת סתירה — עדיין אין פתרון.',
      },
    ],
    shortcuts: [
      'מערכת הומוגנית + m < n → אוטומטית יש פתרון לא טריוויאלי.',
      'מטריצה מרובעת n×n עם דרגה n → פתרון יחיד.',
      'שורת סתירה בכל שלב → עצור. אין פתרון.',
    ],
    cheatSheet: [
      '(0...0 | c≠0) = אין פתרון.',
      'חופשיים = עמודות - דרגה.',
      '0 חופשיים = יחיד. ≥1 = אינסוף.',
      'הומוגנית: תמיד x=0. m<n → גם פתרון לא טריוויאלי.',
      'פתרון = פרטי + הומוגני.',
      'שורת אפסים ≠ סתירה.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 4 — Vector Spaces & Subspaces
  // ══════════════════════════════════════════
  {
    number: 4,
    title: 'מרחבים וקטוריים ותת-מרחבים',
    topic: 'vector-spaces',
    mindset: [
      'שיעורי בית 4 הוא הליבה של הקורס. הוכחות תת-מרחב מופיעות כמעט בכל מבחן.',
      'הטעות הנפוצה: לשכוח לבדוק 0 ∈ W, או לערבב בין "סגור לחיבור" ל"סגור לכפל בסקלר".',
      'גישה: 3 תנאים ותו לא. כל שאלת תת-מרחב היא אותו שלד.',
    ],
    goldenRules: [
      'הוכחת תת-מרחב: בדוק 3 תנאים ותו לא: (1) 0 ∈ W, (2) סגור ל-+, (3) סגור ל-כפל בסקלר.',
      'הפרכת תת-מרחב: מספיק שתנאי אחד נכשל.',
      'הדרך הכי מהירה להפריך: 0 ∉ W → סוף.',
      'חיתוך תת-מרחבים הוא תמיד תת-מרחב.',
      'איחוד תת-מרחבים הוא תת-מרחב רק אם אחד מוכל בשני.',
      'קבוצה ריקה היא לא מרחב וקטורי (אין וקטור אפס).',
      '{(x,y) : x ≥ 0} לא תת-מרחב (לא סגור לכפל ב-(-1)).',
      'מרחב וקטורי מעל שדה אינסופי לא יכול להיות איחוד סופי של תת-מרחבים ממשיים.',
    ],
    identification: [
      {
        type: 'הוכח ש-W תת-מרחב',
        signals: [
          '"הוכח ש-W תת-מרחב של V"',
          'W מוגדר על ידי תנאי לינארי: x+y+z=0, Aᵀ=A, וכד\'',
          'עבודה: 3 תנאים. קח שניים כלליים, חבר, כפול.',
        ],
      },
      {
        type: 'הוכח ש-V אינו מרחב וקטורי',
        signals: [
          '"הוכח שאינו מ"ו" / "הפרך"',
          'חפש: אקסיומה שנכשלת',
          'טיפ: נסה קודם סגירות, אח"כ וקטור אפס',
        ],
      },
      {
        type: 'שאלת איחוד/חיתוך',
        signals: [
          '"האם U ∪ W תת-מרחב?"',
          'חיתוך — תמיד כן.',
          'איחוד — רק אם U ⊆ W או W ⊆ U.',
        ],
      },
    ],
    strategies: [
      {
        name: 'הוכחת תת-מרחב — שלד קבוע',
        steps: [
          'שלב 1: הוכח 0 ∈ W. הצב 0 ובדוק שמקיים את התנאי.',
          'שלב 2: קח u, v ∈ W כלליים (כלומר מקיימים את התנאי). הוכח u + v ∈ W.',
          'שלב 3: קח u ∈ W, α סקלר. הוכח α·u ∈ W.',
          'שלב 4: סיכום: "W לא ריק, סגור ל-+ ולכפל בסקלר → תת-מרחב."',
        ],
      },
      {
        name: 'הוכחת "לא מרחב וקטורי"',
        steps: [
          'שלב 1: נסה 0 ∉ V.',
          'שלב 2: נסה אי-סגירות: מצא v ∈ V כך ש-(-1)·v ∉ V.',
          'שלב 3: נסה אי-סגירות לחיבור: מצא u,v ∈ V כך ש-u+v ∉ V.',
          'שלב 4: מספיק דוגמה אחת.',
        ],
      },
      {
        name: 'הוכחת U ∪ W תת-מרחב ⟺ U ⊆ W או W ⊆ U',
        steps: [
          'שלב 1 (⟸): אם U ⊆ W אז U ∪ W = W, שהוא תת-מרחב.',
          'שלב 2 (⟹ בשלילה): הנח U ⊄ W וגם W ⊄ U.',
          'שלב 3: קח u ∈ U\\W ו-w ∈ W\\U.',
          'שלב 4: u+w ∈ U∪W → u+w ∈ U או u+w ∈ W → סתירה.',
        ],
      },
    ],
    traps: [
      {
        trap: '"W לא ריק" מספיק',
        wrong: 'בדקתי ש-W ≠ ∅, אז הוא תת-מרחב',
        right: 'צריך גם 0 ∈ W, סגירות ל-+, וסגירות לכפל בסקלר.',
      },
      {
        trap: 'חיתוך שני מרחבים = קבוצה ריקה',
        wrong: 'U ∩ W יכול להיות ריק',
        right: '0 ∈ U ו-0 ∈ W → 0 ∈ U∩W. לעולם לא ריק.',
      },
      {
        trap: 'איחוד תת-מרחבים = תת-מרחב',
        wrong: 'U ∪ W תמיד תת-מרחב',
        right: 'רק אם U ⊆ W או W ⊆ U! דוגמה: ציר X ∪ ציר Y ∌ (1,1).',
      },
    ],
    shortcuts: [
      'W מוגדר ע"י Ax = 0 → אוטומטית תת-מרחב (מרחב הפתרונות של מערכת הומוגנית).',
      'חיתוך → תמיד תת-מרחב. אל תוכיח מחדש.',
      '0 ∉ W → מיד לא תת-מרחב.',
    ],
    cheatSheet: [
      'תת-מרחב = 0∈W + סגור ל-+ + סגור ל-כפל.',
      'חיתוך = תמיד תת-מרחב.',
      'איחוד = תת-מרחב ⟺ הכלה.',
      '0 ∉ W → לא תת-מרחב.',
      'V = ∅ → לא מ"ו (אין 0).',
      'x ≥ 0 → לא סגור לכפל ב-(-1).',
      'Ax = 0 → אוטומטית תת-מרחב.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 5 — Span (פרישה)
  // ══════════════════════════════════════════
  {
    number: 5,
    title: 'פרישה (Span)',
    topic: 'span',
    mindset: [
      'שיעורי בית 5 בודק הבנה של "מה אפשר לייצר" מקבוצת וקטורים.',
      'הטעות הנפוצה: להניח ש-Sp(v₁,v₂) = Sp(v₁) ∪ Sp(v₂). זה לא נכון!',
      'גישה: Span = כל הצירופים הלינאריים. הוכחות עובדות דרך "v מתפרש כצ"ל".',
    ],
    goldenRules: [
      'v ∈ Sp(S) ⟺ קיימים סקלרים כך ש-v = Σαᵢvᵢ.',
      'Sp(S) הוא תמיד תת-מרחב (סגור ל-+ ולכפל בסקלר).',
      'Sp(v₁,...,vₖ) ⊆ Sp(v₁,...,vₖ,u) תמיד. הוספת וקטור לא מקטינה פרישה.',
      'אם u ∈ Sp(v₁,...,vₖ) אז Sp(v₁,...,vₖ,u) = Sp(v₁,...,vₖ). הוספתו מיותרת.',
      'Sp(v₁,v₂) ≠ Sp(v₁) ∪ Sp(v₂) בכלל!',
      'v ∈ Sp(v₁,v₂,v₃), v ∉ Sp(v₁,v₂) → v₃ ∉ Sp(v₁,v₂).',
      'כדי להוכיח Sp(A) = Sp(B): הוכח A ⊆ Sp(B) וגם B ⊆ Sp(A).',
      'הפרישה של קבוצה ריקה היא {0}.',
    ],
    identification: [
      {
        type: 'הוכח/הפרך תכונת פרישה',
        signals: [
          '"הוכח/הפרך: אם ... אז Sp(...)=Sp(...)"',
          'שאלת הוכח/הפרך: תחפש דוגמה נגדית קודם',
          'אם נראה נכון: הוכח הכלה דו-כיוונית',
        ],
      },
      {
        type: 'מצא קבוצה פורשת',
        signals: [
          '"מצא קבוצה פורשת ל-W" / "הוכח ש-W = Sp(...)"',
          'קח איבר כללי ב-W, פרק לגורמים',
          'הגורמים הם הוקטורים הפורשים',
        ],
      },
    ],
    strategies: [
      {
        name: 'הוכחת Sp(A) = Sp(B)',
        steps: [
          'שלב 1: הוכח Sp(A) ⊆ Sp(B) — כל וקטור ב-A הוא צ"ל של וקטורים ב-B.',
          'שלב 2: הוכח Sp(B) ⊆ Sp(A) — כל וקטור ב-B הוא צ"ל של וקטורים ב-A.',
          'שלב 3: מסקנה: Sp(A) = Sp(B).',
        ],
      },
      {
        name: 'הפרכת טענת פרישה',
        steps: [
          'שלב 1: חפש דוגמה נגדית ב-R² או R³ (הכי פשוט).',
          'שלב 2: השתמש בוקטורי סטנדרט e₁, e₂.',
          'שלב 3: הראה שהטענה נכשלת בדוגמה.',
        ],
      },
      {
        name: 'מציאת קבוצה פורשת לתת-מרחב',
        steps: [
          'שלב 1: כתוב איבר כללי של W: (x,y,z) עם התנאי.',
          'שלב 2: השתמש בתנאי לבטא משתנה אחד דרך אחרים.',
          'שלב 3: פרק: (x,y,z) = x·v₁ + y·v₂ + ...',
          'שלב 4: הוקטורים v₁,v₂,... הם הקבוצה הפורשת.',
        ],
      },
    ],
    traps: [
      {
        trap: 'Sp(v₁,v₂) = Sp(v₁) ∪ Sp(v₂)',
        wrong: 'הפרישה של שניים = איחוד הפרישות',
        right: 'Sp(e₁,e₂) = R² אבל Sp(e₁) ∪ Sp(e₂) = ציר X ∪ ציר Y ≠ R².',
      },
      {
        trap: 'v ∈ Sp(v₁,v₂,v₃) → v ∈ Sp(v₁) או v ∈ Sp(v₂,v₃)',
        wrong: 'ההשתייכות "מתפרקת"',
        right: 'v = α₁v₁ + α₂v₂ + α₃v₃ לא אומר ש-v שייך רק לחלק מהפורשים.',
      },
    ],
    shortcuts: [
      'u ∈ Sp(S) → Sp(S ∪ {u}) = Sp(S). הוספת וקטור תלוי = מיותר.',
      'W = {(x,y,z): x+y+z=0} → W = Sp{(-1,1,0),(-1,0,1)} — ישר מהתנאי.',
      'להוכיח Sp(A) ⊆ Sp(B): מספיק שכל וקטור ב-A שייך ל-Sp(B).',
    ],
    cheatSheet: [
      'Sp(S) = כל הצירופים הלינאריים של S.',
      'Sp(S) = תת-מרחב תמיד.',
      'u ∈ Sp(S) → הוספת u לא משנה.',
      'Sp(A) = Sp(B) ⟺ הכלה דו-כיוונית.',
      'Sp(v₁,v₂) ≠ Sp(v₁) ∪ Sp(v₂).',
      'Sp(∅) = {0}.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 6 — Linear Independence
  // ══════════════════════════════════════════
  {
    number: 6,
    title: 'תלות ואי-תלות לינארית',
    topic: 'linear-independence',
    mindset: [
      'שיעורי בית 6 הוא בין הנושאים הכי נבחנים. כמעט כל מבחן כולל שאלת בת"ל/ת"ל.',
      'הטעות הנפוצה: לבלבל בין "שורה של אפסים" ל"תלות", או לשכוח שהבדיקה היא על עמודות.',
      'גישה: α₁v₁ + ... + αₖvₖ = 0 → מה ניתן להסיק על הסקלרים.',
    ],
    goldenRules: [
      'בת"ל: α₁v₁+...+αₖvₖ=0 → כל ה-αᵢ = 0 (רק הפתרון הטריוויאלי).',
      'ת"ל: קיים צירוף לא טריוויאלי ש-= 0 (יש αᵢ ≠ 0).',
      'אם יש משתנה חופשי בדירוג → ת"ל.',
      'אם אין משתנה חופשי (דרגה = מספר וקטורים) → בת"ל.',
      'שורת אפסים ≠ תלות. שורת אפסים = משוואה טריוויאלית.',
      'תלות/בת"ל נקבעת לפי עמודות, לא לפי שורות.',
      'אם k > dim(V) → הוקטורים בהכרח ת"ל.',
      'אם v₁,...,vₖ בת"ל ו-u ∉ Sp(v₁,...,vₖ) → v₁,...,vₖ,u בת"ל.',
      'בת"ל נשמרת תחת החלפת u ב-u+v כאשר v ∈ Sp{v₁,...,vₖ}.',
    ],
    identification: [
      {
        type: 'הוכח ת"ל',
        signals: [
          '"הוכח שהוקטורים תלויים לינארית"',
          'דרכים: מצא צ"ל לא טריוויאלי, או הראה אחד כצ"ל של אחרים',
          'טיפ: נסה קודם לראות אם vₖ = Σvᵢ',
        ],
      },
      {
        type: 'הוכח בת"ל',
        signals: [
          '"הוכח שבת"ל" / "independent"',
          'דרך 1: דרג את מטריצת הוקטורים ובדוק שאין משתנה חופשי',
          'דרך 2: הנח α₁v₁+...=0 והוכח שכולם 0',
        ],
      },
      {
        type: 'בת"ל עם פרמטר',
        signals: [
          '"לאילו ערכי α הוקטורים בת"ל?"',
          'דרג עם α כפרמטר',
          'מצא α שיוצר שורת אפסים / עמודה חופשית',
        ],
      },
    ],
    strategies: [
      {
        name: 'בדיקת בת"ל/ת"ל — מטריצה',
        steps: [
          'שלב 1: סדר וקטורים כעמודות (או שורות) במטריצה.',
          'שלב 2: דרג לצורה מדורגת.',
          'שלב 3: אם דרגה = מספר וקטורים → בת"ל.',
          'שלב 4: אם דרגה < מספר וקטורים → ת"ל.',
        ],
      },
      {
        name: 'הוכחת בת"ל ישירה (ללא מטריצה)',
        steps: [
          'שלב 1: הנח α₁v₁ + α₂v₂ + ... + αₖvₖ = 0.',
          'שלב 2: פתח לפי רכיבים (או השתמש בנתון).',
          'שלב 3: הסק שכל αᵢ = 0.',
          'שלב 4: סיכום: הפתרון היחיד הוא הטריוויאלי → בת"ל.',
        ],
      },
      {
        name: 'בת"ל עם פרמטר',
        steps: [
          'שלב 1: בנה מטריצה עם α כפרמטר.',
          'שלב 2: דרג. ביטוי שתלוי ב-α יופיע.',
          'שלב 3: בת"ל ⟺ הביטוי ≠ 0.',
          'שלב 4: ת"ל ⟺ הביטוי = 0. פתור עבור α.',
        ],
      },
    ],
    traps: [
      {
        trap: 'שורת אפסים = ת"ל',
        wrong: 'יש שורת אפסים בדירוג → ת"ל',
        right: 'שורת אפסים רק אומרת שמשוואה אחת מיותרת. ת"ל נקבע לפי עמודות חופשיות.',
      },
      {
        trap: '3 וקטורים ב-R³ תמיד בת"ל',
        wrong: 'מספר וקטורים = מימד → בת"ל',
        right: 'לא בהכרח! צריך שהדרגה תהיה 3. למשל (1,0,0),(0,1,0),(1,1,0) — ת"ל!',
      },
      {
        trap: 'בדיקת ת"ל על שורות במקום עמודות',
        wrong: 'שורות המטריצה תלויות → הוקטורים תלויים',
        right: 'אם הוקטורים הם העמודות, בדוק עמודות. שורות ≠ עמודות.',
      },
      {
        trap: 'בדירוג מעל Z₅ — שוכחים mod',
        wrong: 'חושבים ב-R ומקבלים שברים',
        right: 'כל חשבון mod 5. אין שברים. הפיכויות: 2⁻¹=3, 3⁻¹=2, 4⁻¹=4.',
      },
    ],
    shortcuts: [
      'k > n (יותר וקטורים ממימד) → אוטומטית ת"ל.',
      'det ≠ 0 ⟺ בת"ל (למטריצה מרובעת).',
      'אם אפשר לראות ש-v₃ = v₁ + v₂ → ת"ל. בלי דירוג.',
      'מעל Z₅: הפיכויות 1⁻¹=1, 2⁻¹=3, 3⁻¹=2, 4⁻¹=4.',
    ],
    cheatSheet: [
      'בת"ל = רק פתרון טריוויאלי.',
      'ת"ל = יש פתרון לא טריוויאלי.',
      'משתנה חופשי = ת"ל.',
      'k > dim(V) → ת"ל.',
      'שורת אפסים ≠ תלות.',
      'det ≠ 0 ⟺ בת"ל.',
      'מעל Z₅: כל חשבון mod 5.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 8 — Basis, Dimension, Matrix Mult.
  // ══════════════════════════════════════════
  {
    number: 8,
    title: 'כפל מטריצות, בסיס ומימד',
    topic: 'basis-dimension',
    mindset: [
      'שיעורי בית 8 מכסה את המושגים המרכזיים: בסיס, מימד, ונוסחת המימדים. כמעט בכל מבחן.',
      'הטעות הנפוצה: לשכוח שבסיס = פורשת + בת"ל, ולהוכיח רק אחד מהשניים.',
      'גישה: תמיד בדוק את שני התנאים. נוסחת המימדים — נשק סודי.',
    ],
    goldenRules: [
      'בסיס = קבוצה בת"ל + פורשת.',
      'כל בסיס למרחב מאותו מימד מכיל את אותו מספר וקטורים.',
      'dim(V) = n → כל n וקטורים בת"ל מהווים בסיס. כל n וקטורים פורשים מהווים בסיס.',
      'נוסחת המימדים: dim(W₁+W₂) = dim(W₁) + dim(W₂) - dim(W₁∩W₂).',
      'סכום ישר: W₁ ∩ W₂ = {0} → dim(W₁⊕W₂) = dim(W₁) + dim(W₂).',
      'כפל מטריצות: (AB)ᵢⱼ = שורה i של A · עמודה j של B.',
      'AB ≠ BA בכלל. כפל מטריצות לא קומוטטיבי!',
      'A(B+C) = AB + AC. חילוקיות כן עובדת.',
      '(AB)C = A(BC). אסוציאטיביות כן עובדת.',
    ],
    identification: [
      {
        type: 'מצא בסיס ומימד',
        signals: [
          '"מצא בסיס ל-W" / "חשב dim(W)"',
          'אם W מוגדר ע"י תנאים: מצא קבוצה פורשת ← הוכח בת"ל',
          'אם W מוגדר ע"י מערכת: דרג ← עמודות ציר = בסיס',
        ],
      },
      {
        type: 'אמת נוסחת מימדים',
        signals: [
          '"אמת את נוסחת המימדים" / "חשב dim(W₁+W₂)"',
          'מצא dim(W₁), dim(W₂), dim(W₁∩W₂)',
          'ודא: dim(W₁+W₂) = dim(W₁) + dim(W₂) - dim(W₁∩W₂)',
        ],
      },
      {
        type: 'כפל מטריצות',
        signals: [
          '"חשב AB" / "הוכח שכפל מטריצות..."',
          'ודא תאימות מידות: A(m×n) · B(n×p) = C(m×p)',
        ],
      },
    ],
    strategies: [
      {
        name: 'מציאת בסיס לתת-מרחב',
        steps: [
          'שלב 1: כתוב איבר כללי של W עם התנאים.',
          'שלב 2: השתמש בתנאים לבטא משתנה אחד דרך אחרים.',
          'שלב 3: פרק לצ"ל: v = α·v₁ + β·v₂ + ...',
          'שלב 4: {v₁, v₂, ...} = קבוצה פורשת. ודא בת"ל (בד"כ אוטומטי).',
          'שלב 5: dim(W) = מספר הוקטורים בבסיס.',
        ],
      },
      {
        name: 'מציאת W₁ ∩ W₂',
        steps: [
          'שלב 1: כתוב v ∈ W₁ כצ"ל של בסיס W₁.',
          'שלב 2: כתוב v ∈ W₂ כצ"ל של בסיס W₂.',
          'שלב 3: השווה: α₁u₁+α₂u₂ = β₁w₁+β₂w₂.',
          'שלב 4: פתור את המערכת. הציב בחזרה.',
        ],
      },
    ],
    traps: [
      {
        trap: 'בת"ל = בסיס',
        wrong: 'מצאתי 2 וקטורים בת"ל ב-R³ → בסיס',
        right: 'בסיס = בת"ל + פורשת. 2 בת"ל ב-R³ לא פורשים את R³.',
      },
      {
        trap: 'AB = BA',
        wrong: 'כפל מטריצות קומוטטיבי',
        right: 'AB ≠ BA בכלל. אפילו AB יכול להתקיים ו-BA לא (מידות שונות).',
      },
      {
        trap: 'dim(W₁+W₂) = dim(W₁) + dim(W₂)',
        wrong: 'מימד הסכום = סכום המימדים',
        right: 'רק אם W₁ ∩ W₂ = {0}. אחרת צריך לחסר dim(W₁∩W₂).',
      },
    ],
    shortcuts: [
      'dim(V) = n, מצאת n וקטורים בת"ל → בסיס (לא צריך לבדוק פרישה).',
      'dim(V) = n, מצאת n וקטורים פורשים → בסיס (לא צריך לבדוק בת"ל).',
      'W₁ ∩ W₂ = {0} → dim(W₁+W₂) = dim(W₁) + dim(W₂) ישר.',
      'W ⊆ V, dim(W) = dim(V) → W = V.',
    ],
    cheatSheet: [
      'בסיס = בת"ל + פורשת.',
      'dim(V)=n → n בת"ל = בסיס = n פורשים.',
      'נוסחת מימדים: dim(W₁+W₂) = dim(W₁)+dim(W₂)-dim(W₁∩W₂).',
      'AB ≠ BA.',
      'W ⊆ V, dim(W)=dim(V) → W=V.',
      '(AB)ᵢⱼ = שורה i · עמודה j.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 9 — Matrix Invertibility
  // ══════════════════════════════════════════
  {
    number: 9,
    title: 'הפיכות מטריצות',
    topic: 'invertible-matrices',
    mindset: [
      'שיעורי בית 9 מלמד את אחת המיומנויות הכי חשובות: חישוב הופכי ובדיקת הפיכות.',
      'הטעות הנפוצה: לשכוח ש-(AB)⁻¹ = B⁻¹A⁻¹ (סדר הפוך!), או לטעות בדירוג עם פרמטר.',
      'גישה: [A|I] → דרג → אם שמאל = I → ימין = A⁻¹.',
    ],
    goldenRules: [
      'A הפיכה ⟺ det(A) ≠ 0 ⟺ דרגה מלאה ⟺ Ax=0 רק פתרון טריוויאלי.',
      'חישוב הופכי: [A|I] → דירוג → [I|A⁻¹].',
      'אם מופיעה שורת אפסים בצד שמאל → A לא הפיכה.',
      '(AB)⁻¹ = B⁻¹A⁻¹. סדר הפוך!',
      '(Aᵀ)⁻¹ = (A⁻¹)ᵀ.',
      'A² = I → A הפיכה ו-A⁻¹ = A.',
      'AB הפיכה → A הפיכה וגם B הפיכה.',
      'A הפיכה ⟹ A מרובעת. מטריצה לא מרובעת לעולם לא הפיכה.',
      'נוסחת 2×2: אם A = [[a,b],[c,d]] אז A⁻¹ = (1/(ad-bc))·[[d,-b],[-c,a]].',
    ],
    identification: [
      {
        type: 'חשב A⁻¹',
        signals: [
          '"מצא את ההופכי" / "חשב A⁻¹"',
          'בנה [A|I] ודרג',
          'אם 2×2 → שקול נוסחה ישירה',
        ],
      },
      {
        type: 'הפיכות עם פרמטר',
        signals: [
          '"לאילו ערכי α מטריצה A הפיכה?"',
          'דרג [A|I] עם α → מצא α שיוצר שורת אפסים',
          'A הפיכה ⟺ α לא יוצר שורת אפסים',
        ],
      },
      {
        type: 'הוכח/הפרך הפיכות',
        signals: [
          '"הוכח ש-A הפיכה" / "הפרך..."',
          'להוכחה: הראה ש-AB = I לאיזה B, או שדרגה מלאה',
          'להפרכה: מצא x≠0 כך ש-Ax=0',
        ],
      },
    ],
    strategies: [
      {
        name: 'חישוב הופכי — [A|I]',
        steps: [
          'שלב 1: בנה מטריצה מורחבת [A|I].',
          'שלב 2: דרג לצורה מדורגת.',
          'שלב 3: אם שורת אפסים בשמאל → A לא הפיכה. עצור.',
          'שלב 4: המשך דירוג עד [I|B]. אז B = A⁻¹.',
          'שלב 5: ודא: A·A⁻¹ = I.',
        ],
      },
      {
        name: 'הוכחת הפיכות ממשוואה',
        steps: [
          'שלב 1: מהמשוואה (למשל A²=I, AB=I), הסק מיהו ההופכי.',
          'שלב 2: A² = I → A·A = I → A⁻¹ = A.',
          'שלב 3: AB = I → A הפיכה ו-A⁻¹ = B (כי מרובעת).',
          'שלב 4: B = A³ - A = A(A²-I) → אם B הפיכה, אז A הפיכה.',
        ],
      },
    ],
    traps: [
      {
        trap: '(AB)⁻¹ = A⁻¹B⁻¹',
        wrong: 'סדר רגיל',
        right: '(AB)⁻¹ = B⁻¹A⁻¹. סדר הפוך! כמו להוריד גרביים לפני נעליים.',
      },
      {
        trap: 'A הפיכה → A+B הפיכה',
        wrong: 'הפיכות "עוברת" לסכום',
        right: 'לא! A = I הפיכה, B = -I הפיכה, אבל A+B = 0 לא הפיכה.',
      },
      {
        trap: 'AB = 0 → A = 0 או B = 0',
        wrong: 'כמו שדה, אין מחלקי אפס',
        right: 'במטריצות יש מחלקי אפס! AB = 0 לא גורר A=0 או B=0.',
      },
    ],
    shortcuts: [
      '2×2: A⁻¹ = (1/det)·[[d,-b],[-c,a]] — בלי דירוג.',
      'A²=I → A⁻¹=A. A³=I → A⁻¹=A². וכן הלאה.',
      'AB הפיכה → שתיהן הפיכות (למרובעות).',
      'det(A) ≠ 0 ⟺ A הפיכה — בלי דירוג.',
    ],
    cheatSheet: [
      '[A|I] → [I|A⁻¹].',
      'שורת אפסים בשמאל → לא הפיכה.',
      '(AB)⁻¹ = B⁻¹A⁻¹.',
      'A²=I → A⁻¹=A.',
      'AB הפיכה → A,B הפיכות.',
      '2×2: (1/det)·[[d,-b],[-c,a]].',
      'det ≠ 0 ⟺ הפיכה.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 10 — Invertibility, Equivalence, Trace
  // ══════════════════════════════════════════
  {
    number: 10,
    title: 'הפיכות, מערכות שקולות, עקבה',
    topic: 'trace-equivalence',
    mindset: [
      'שיעורי בית 10 מכסה נושאים מתקדמים: שקילות מערכות, משוואות מטריציות, ומטריצות אידמפוטנטיות.',
      'הטעות הנפוצה: להניח שכפל במטריצה הפיכה משמר הכל (כן לפתרונות Ax=0, לא ל-Ax=b).',
      'גישה: חשוב "מה P הפיכה שומרת ומה לא".',
    ],
    goldenRules: [
      'P הפיכה: Ax=0 ⟺ (PA)x=0. מערכות הומוגניות שקולות!',
      'P הפיכה: Ax=b ⟹ (PA)x=Pb אבל (PA)x=b לא בהכרח (b≠Pb).',
      'tr(A) = סכום האלכסון הראשי = Σaᵢᵢ.',
      'tr(AB) = tr(BA). תמיד. (גם אם AB ≠ BA.)',
      'tr(A+B) = tr(A) + tr(B). לינאריות.',
      'tr(cA) = c·tr(A).',
      'A² = A (אידמפוטנטית): (I-A)² = I-A גם. rank(A)+rank(I-A)=n.',
      'ממשוואה A+B = A³: B = A(A²-I). אם B הפיכה → A הפיכה.',
      'מטריצה עם הופכי ימני על מטריצה מרובעת → הפיכה.',
    ],
    identification: [
      {
        type: 'שקילות מערכות',
        signals: [
          '"האם Ax=0 ו-(PA)x=0 שקולות?"',
          'P הפיכה → כן! (כפול ב-P / P⁻¹)',
          'P הפיכה + Ax=b → (PA)x=Pb ≠ (PA)x=b',
        ],
      },
      {
        type: 'הוכחת הפיכות ממשוואה',
        signals: [
          '"נתון A+B=A³. הוכח: B הפיכה → A הפיכה"',
          'פרק: B = A(A²-I)',
          'B הפיכה → A יש הופכי ימני → A הפיכה',
        ],
      },
      {
        type: 'מטריצה אידמפוטנטית',
        signals: [
          '"A²=A" / "אידמפוטנטית"',
          'תכונות: I-A גם אידמפוטנטית',
          'rank(A)+rank(I-A)=n',
        ],
      },
      {
        type: 'תכונות עקבה',
        signals: [
          '"tr(...)=" / "הוכח ש-tr(AB)=tr(BA)"',
          'פתח לפי הגדרה: tr(A) = Σaᵢᵢ',
          'השתמש ב-tr(AB) = ΣᵢΣⱼaᵢⱼbⱼᵢ',
        ],
      },
    ],
    strategies: [
      {
        name: 'הוכחת הפיכות ממשוואה מטריצית',
        steps: [
          'שלב 1: בודד את A ממשוואה — מצא ביטוי A·(...) = ... או (...)·A = ...',
          'שלב 2: אם AB = I לאיזה B → A הפיכה.',
          'שלב 3: אם A·(ביטוי) = B ו-B הפיכה → A יש הופכי ימני → A הפיכה.',
        ],
      },
      {
        name: 'הוכחת tr(AB) = tr(BA)',
        steps: [
          'שלב 1: tr(AB) = Σᵢ(AB)ᵢᵢ = ΣᵢΣⱼaᵢⱼbⱼᵢ.',
          'שלב 2: שנה סדר סכימה: = ΣⱼΣᵢbⱼᵢaᵢⱼ.',
          'שלב 3: = Σⱼ(BA)ⱼⱼ = tr(BA).',
        ],
      },
    ],
    traps: [
      {
        trap: 'Ax=b ⟺ (PA)x=b כאשר P הפיכה',
        wrong: 'כפל במטריצה הפיכה שומר שקילות תמיד',
        right: 'רק למערכת הומוגנית! Ax=b → (PA)x = Pb ≠ b (אלא אם Pb=b).',
      },
      {
        trap: 'tr(AB) = tr(A)·tr(B)',
        wrong: 'עקבה של מכפלה = מכפלת עקבות',
        right: 'tr(AB) = tr(BA) ≠ tr(A)·tr(B). עקבה לא כפלית!',
      },
      {
        trap: 'A² = A → A = 0 או A = I',
        wrong: 'כמו x²=x בשדה',
        right: 'במטריצות יש אידמפוטנטיות לא טריוויאליות! למשל [[1,0],[0,0]].',
      },
    ],
    shortcuts: [
      'tr(AB) = tr(BA) — ישירות, בלי חישוב.',
      'A²=A → rank(A)+rank(I-A)=n — ישר.',
      'B הפיכה ו-B=A(expression) → A הפיכה.',
    ],
    cheatSheet: [
      'P הפיכה: Ax=0 ⟺ (PA)x=0.',
      'P הפיכה: Ax=b ≠ (PA)x=b.',
      'tr(AB)=tr(BA).',
      'tr(A+B)=tr(A)+tr(B).',
      'A²=A → (I-A)²=I-A.',
      'rank(A)+rank(I-A)=n (אידמפוטנטית).',
      'הופכי ימני למרובעת → הפיכה.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 11 — Determinants
  // ══════════════════════════════════════════
  {
    number: 11,
    title: 'דטרמיננטות',
    topic: 'determinants',
    mindset: [
      'שיעורי בית 11 בודק הבנה של תכונות דטרמיננטה — לא רק חישוב.',
      'הטעות הנפוצה: det(A+B) = det(A) + det(B). זה שקר!',
      'גישה: זכור את התכונות. רוב הבעיות הן הוכח/הפרך.',
    ],
    goldenRules: [
      'det(AB) = det(A)·det(B). דטרמיננטה של מכפלה = מכפלת דטרמיננטות.',
      'det(A+B) ≠ det(A) + det(B) בכלל!',
      'det(cA) = cⁿ·det(A) עבור מטריצה n×n.',
      'det(Aᵀ) = det(A).',
      'det(A⁻¹) = 1/det(A).',
      'det(A) = 0 ⟺ A לא הפיכה.',
      'החלפת שורות: det הופך סימן.',
      'כפל שורה ב-c: det נכפל ב-c.',
      'הוספת כפולה של שורה לשורה אחרת: det לא משתנה.',
      'מעל Z₅: כל חשבון mod 5. det(A) = 0 ⟺ det ≡ 0 (mod 5).',
    ],
    identification: [
      {
        type: 'חישוב דטרמיננטה מעל Z₅',
        signals: [
          '"חשב det(A) מעל Z₅"',
          'כל פעולת שורה — mod 5',
          'הפיכויות: 2⁻¹=3, 3⁻¹=2, 4⁻¹=4',
        ],
      },
      {
        type: 'הוכח/הפרך תכונת דטרמיננטה',
        signals: [
          '"הוכח/הפרך: det(...)=..."',
          'להוכחה: השתמש בתכונות ידועות',
          'להפרכה: דוגמה נגדית 2×2 (הכי פשוט)',
        ],
      },
    ],
    strategies: [
      {
        name: 'חישוב det מעל Z₅',
        steps: [
          'שלב 1: כתוב את המטריצה מעל Z₅.',
          'שלב 2: דרג (כל חשבון mod 5). עקוב אחרי פעולות שורה.',
          'שלב 3: det = מכפלת האלכסון × (-1)^(מספר החלפות).',
          'שלב 4: תוצאה mod 5.',
        ],
      },
      {
        name: 'הוכח/הפרך תכונת det',
        steps: [
          'שלב 1: אם נראה שקר → חפש דוגמה נגדית 2×2.',
          'שלב 2: אם נראה נכון → השתמש ב-det(AB)=det(A)det(B) ובתכונות.',
          'שלב 3: det(cA) = cⁿdet(A) — שים לב ל-n!',
        ],
      },
    ],
    traps: [
      {
        trap: 'det(A+B) = det(A) + det(B)',
        wrong: 'דטרמיננטה "לינארית"',
        right: 'דטרמיננטה לינארית בכל שורה, לא בכל המטריצה! det([[1,0],[0,1]]+[[1,0],[0,1]]) = det([[2,0],[0,2]]) = 4 ≠ 1+1=2.',
      },
      {
        trap: 'det(cA) = c·det(A)',
        wrong: 'כמו כפל בסקלר',
        right: 'det(cA) = cⁿ·det(A) כאשר n = מימד המטריצה!',
      },
      {
        trap: 'בחשבון מעל Z₅ — שוכחים mod',
        wrong: 'det = 7 → A הפיכה',
        right: '7 mod 5 = 2 ≠ 0 → כן הפיכה. אבל 10 mod 5 = 0 → לא הפיכה!',
      },
    ],
    shortcuts: [
      'מטריצה משולשית: det = מכפלת האלכסון.',
      'שורת/עמודת אפסים → det = 0.',
      'det(A) ≠ 0 ⟺ הפיכה.',
      'det(AB) = det(A)·det(B) — תמיד.',
      'דוגמה נגדית: תמיד נסה 2×2 קודם.',
    ],
    cheatSheet: [
      'det(AB) = det(A)·det(B).',
      'det(A+B) ≠ det(A)+det(B).',
      'det(cA) = cⁿ·det(A).',
      'det(Aᵀ) = det(A).',
      'החלפת שורות → כפל ב-(-1).',
      'שורת אפסים → det = 0.',
      'Z₅: כל חשבון mod 5.',
    ],
  },

  // ══════════════════════════════════════════
  // HW 12 — Determinant Computations
  // ══════════════════════════════════════════
  {
    number: 12,
    title: 'חישובי דטרמיננטות',
    topic: 'determinant-computations',
    mindset: [
      'שיעורי בית 12 בודק מיומנות חישוב: פיתוח קופקטורים, נוסחאות רקורסיביות, ואינדוקציה.',
      'הטעות הנפוצה: לבחור שורה/עמודה "סתם" במקום עם הכי הרבה אפסים.',
      'גישה: שלב 1 תמיד — חפש שורה/עמודה עם הכי הרבה אפסים. אם יש מבנה → רקורסיה.',
    ],
    goldenRules: [
      'פיתוח לפי שורה i: det(A) = Σⱼ (-1)^(i+j) · aᵢⱼ · Mᵢⱼ.',
      'פיתוח לפי עמודה j: det(A) = Σᵢ (-1)^(i+j) · aᵢⱼ · Mᵢⱼ.',
      'Mᵢⱼ = det(מטריצה בלי שורה i ועמודה j).',
      'בחר שורה/עמודה עם הכי הרבה אפסים — חוסך חישוב!',
      'מטריצה תלת-אלכסונית: det(Aₙ) = a·det(Aₙ₋₁) - bc·det(Aₙ₋₂).',
      'רקורסיה: פתח לפי שורה 1 (או n). קבל נוסחת נסיגה. פתור.',
      'אם יש דפוס חוזר → חשב n=1,2,3 ← נחש נוסחה ← הוכח באינדוקציה.',
      'פעולות שורה לפני פיתוח יכולות לפשט מאוד.',
    ],
    identification: [
      {
        type: 'חישוב det ישיר',
        signals: [
          '"חשב det(A)" למטריצה 4×4 או 5×5',
          'חפש שורה/עמודה עם אפסים',
          'אם אין — עשה פעולת שורה ליצור אפסים',
        ],
      },
      {
        type: 'דטרמיננטה רקורסיבית',
        signals: [
          'מטריצה n×n כללית עם דפוס',
          '"מצא נוסחה ל-det(Aₙ)"',
          'פתח שורה 1 → קבל dₙ = f(dₙ₋₁, dₙ₋₂)',
        ],
      },
      {
        type: 'הוכחה באינדוקציה',
        signals: [
          '"הוכח ש-det(Aₙ) = ..." לכל n',
          'בסיס: n=1,2',
          'צעד: הנח ל-n-1 ו-n-2, הוכח ל-n',
        ],
      },
    ],
    strategies: [
      {
        name: 'פיתוח קופקטורים — 4×4/5×5',
        steps: [
          'שלב 1: בדוק אם יש שורה/עמודה עם אפסים.',
          'שלב 2: אם לא — עשה פעולות שורה ליצור אפסים.',
          'שלב 3: פתח לפי השורה/עמודה הנבחרת.',
          'שלב 4: חשב את ה-det הקטנים (3×3 או 2×2).',
          'שלב 5: סכום עם סימנים: (-1)^(i+j).',
        ],
      },
      {
        name: 'נוסחת נסיגה למטריצה תלת-אלכסונית',
        steps: [
          'שלב 1: חשב d₁ ו-d₂ ישירות.',
          'שלב 2: פתח לפי שורה ראשונה: dₙ = a₁₁·dₙ₋₁ - a₁₂·a₂₁·dₙ₋₂.',
          'שלב 3: פתור רקורסיה (משוואה אופיינית, או חשב כמה ערכים וזהה דפוס).',
          'שלב 4: הוכח באינדוקציה.',
        ],
      },
    ],
    traps: [
      {
        trap: 'שוכחים (-1)^(i+j)',
        wrong: 'פשוט כופלים aᵢⱼ · Mᵢⱼ',
        right: 'חובה: (-1)^(i+j) · aᵢⱼ · Mᵢⱼ. הסימן מתחלף!',
      },
      {
        trap: 'פותחים לפי שורה/עמודה ללא אפסים',
        wrong: 'פותחים לפי שורה 1 תמיד',
        right: 'בחר שורה/עמודה עם הכי הרבה אפסים — חוסך 50%+ חישוב.',
      },
      {
        trap: 'ברקורסיה: שוכחים תנאי התחלה',
        wrong: 'כותבים dₙ = ... בלי d₁, d₂',
        right: 'חייבים d₁ ו-d₂ כתנאי התחלה. בלי זה הרקורסיה לא עובדת.',
      },
    ],
    shortcuts: [
      'שורה/עמודה עם n-1 אפסים → det = ±aᵢⱼ · det(Mᵢⱼ). ישר.',
      'משולשית (עליונה/תחתונה): det = מכפלת אלכסון.',
      'בלוקים משולשים: det = det(בלוק 1) · det(בלוק 2).',
      'תלת-אלכסונית: dₙ = a·dₙ₋₁ - bc·dₙ₋₂.',
    ],
    cheatSheet: [
      'פתח לפי שורה/עמודה עם הכי הרבה אפסים.',
      'det = Σ(-1)^(i+j) · aᵢⱼ · Mᵢⱼ.',
      'משולשית → מכפלת אלכסון.',
      'תלת-אלכסונית → dₙ = a·dₙ₋₁ - bc·dₙ₋₂.',
      'אינדוקציה: d₁, d₂ → צעד.',
      'סימן: (-1)^(i+j). אל תשכח!',
    ],
  },
];

// =============================================
// Section Components
// =============================================

function SectionHeader({ icon, title, color }: { icon: React.ReactNode; title: string; color: string }) {
  return (
    <h3 className={`text-lg font-bold ${color} flex items-center gap-2 mb-3`}>
      {icon}
      {title}
    </h3>
  );
}

function RuleList({ items, color }: { items: string[]; color: string }) {
  return (
    <ul className="space-y-1.5">
      {items.map((item, i) => (
        <li key={i} className="text-sm text-gray-700 flex gap-2">
          <span className={`mt-1.5 w-1.5 h-1.5 rounded-full ${color} flex-shrink-0`} />
          <span>{item}</span>
        </li>
      ))}
    </ul>
  );
}

// =============================================
// HW Section Component
// =============================================

function HWSection({ hw }: { hw: HWData }) {
  const [open, setOpen] = useState(false);

  return (
    <div className="bg-white rounded-xl border border-gray-200 overflow-hidden">
      <button
        onClick={() => setOpen(!open)}
        className="w-full px-6 py-4 flex items-center justify-between hover:bg-gray-50 transition-colors"
      >
        <div className="flex items-center gap-3">
          <span className="bg-indigo-100 text-indigo-700 font-bold text-sm px-3 py-1 rounded-lg">
            HW {hw.number}
          </span>
          <span className="font-bold text-gray-900">{hw.title}</span>
        </div>
        {open ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
      </button>

      {open && (
        <div className="px-6 pb-6 space-y-6 border-t border-gray-100">
          {/* 1. How to Think */}
          <div className="pt-4">
            <SectionHeader
              icon={<BookOpen className="w-5 h-5" />}
              title="איך לחשוב בשיעורי בית הזה"
              color="text-indigo-700"
            />
            <div className="bg-indigo-50 rounded-lg p-4">
              {hw.mindset.map((line, i) => (
                <p key={i} className="text-sm text-indigo-900 mb-1 last:mb-0">{line}</p>
              ))}
            </div>
          </div>

          {/* 2. Golden Rules */}
          <div>
            <SectionHeader
              icon={<Target className="w-5 h-5" />}
              title="כללי זהב"
              color="text-amber-700"
            />
            <div className="bg-amber-50 rounded-lg p-4">
              <RuleList items={hw.goldenRules} color="bg-amber-500" />
            </div>
          </div>

          {/* 3. Identification Heuristics */}
          <div>
            <SectionHeader
              icon={<Search className="w-5 h-5" />}
              title="זיהוי סוג השאלה — איך מזהים?"
              color="text-blue-700"
            />
            <div className="space-y-3">
              {hw.identification.map((item, i) => (
                <div key={i} className="bg-blue-50 rounded-lg p-4">
                  <div className="font-semibold text-blue-900 text-sm mb-2">{item.type}</div>
                  <ul className="space-y-1">
                    {item.signals.map((sig, j) => (
                      <li key={j} className="text-sm text-blue-800 flex gap-2">
                        <span className="text-blue-400">&#8226;</span>
                        {sig}
                      </li>
                    ))}
                  </ul>
                </div>
              ))}
            </div>
          </div>

          {/* 4. Step-by-Step Strategies */}
          <div>
            <SectionHeader
              icon={<ListChecks className="w-5 h-5" />}
              title="אסטרטגיות פתרון — שלב אחרי שלב"
              color="text-green-700"
            />
            <div className="space-y-3">
              {hw.strategies.map((strat, i) => (
                <div key={i} className="bg-green-50 rounded-lg p-4">
                  <div className="font-semibold text-green-900 text-sm mb-2">{strat.name}</div>
                  <ol className="space-y-1">
                    {strat.steps.map((step, j) => (
                      <li key={j} className="text-sm text-green-800">{step}</li>
                    ))}
                  </ol>
                </div>
              ))}
            </div>
          </div>

          {/* 5. Common Traps */}
          <div>
            <SectionHeader
              icon={<ShieldAlert className="w-5 h-5" />}
              title="מלכודות נפוצות ואינטואיציות שגויות"
              color="text-red-700"
            />
            <div className="space-y-3">
              {hw.traps.map((trap, i) => (
                <div key={i} className="bg-red-50 rounded-lg p-4">
                  <div className="font-semibold text-red-900 text-sm mb-1">{trap.trap}</div>
                  <div className="text-sm text-red-700 mb-1">
                    <span className="font-medium">מה חושבים:</span> {trap.wrong}
                  </div>
                  <div className="text-sm text-green-700">
                    <span className="font-medium">מה נכון:</span> {trap.right}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* 6. Exam Shortcuts */}
          <div>
            <SectionHeader
              icon={<Rocket className="w-5 h-5" />}
              title="קיצורי דרך למבחן"
              color="text-purple-700"
            />
            <div className="bg-purple-50 rounded-lg p-4">
              <RuleList items={hw.shortcuts} color="bg-purple-500" />
            </div>
          </div>

          {/* 7. Ultra-Short Cheat Sheet */}
          <div>
            <SectionHeader
              icon={<Zap className="w-5 h-5" />}
              title="דף סיכום אולטרה-קצר"
              color="text-orange-700"
            />
            <div className="bg-gray-900 rounded-lg p-4">
              <div className="space-y-1">
                {hw.cheatSheet.map((line, i) => (
                  <div key={i} className="text-sm text-green-400 font-mono">{line}</div>
                ))}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// =============================================
// Main Page
// =============================================

export default function GoldenRulesPage() {
  const [expandAll, setExpandAll] = useState(false);

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      {/* Header */}
      <div className="bg-gradient-to-l from-amber-600 to-orange-600 rounded-2xl p-6 text-white">
        <div className="flex items-center gap-3 mb-2">
          <Target className="w-8 h-8" />
          <h1 className="text-2xl font-bold">Golden Rules &amp; Problem-Solving Heuristics</h1>
        </div>
        <p className="text-amber-100 text-sm">
          כללי זהב, אסטרטגיות פתרון, ומלכודות נפוצות — לכל שיעורי בית.
          לא סיכום. מדריך החלטות מעשי ללחץ מבחן.
        </p>
      </div>

      {/* Controls */}
      <div className="flex justify-between items-center">
        <span className="text-sm text-gray-500">{hwData.length} שיעורי בית</span>
        <button
          onClick={() => setExpandAll(!expandAll)}
          className="text-sm text-indigo-600 hover:text-indigo-800 font-medium"
        >
          {expandAll ? 'סגור הכל' : 'פתח הכל'}
        </button>
      </div>

      {/* HW Sections */}
      {expandAll
        ? hwData.map(hw => <HWOpenSection key={hw.number} hw={hw} />)
        : hwData.map(hw => <HWSection key={hw.number} hw={hw} />)
      }
    </div>
  );
}

// Version that's always open (for expandAll)
function HWOpenSection({ hw }: { hw: HWData }) {
  return (
    <div className="bg-white rounded-xl border border-gray-200 overflow-hidden">
      <div className="px-6 py-4 bg-gray-50 border-b border-gray-100">
        <div className="flex items-center gap-3">
          <span className="bg-indigo-100 text-indigo-700 font-bold text-sm px-3 py-1 rounded-lg">
            HW {hw.number}
          </span>
          <span className="font-bold text-gray-900">{hw.title}</span>
        </div>
      </div>
      <div className="px-6 pb-6 space-y-6">
        {/* 1. How to Think */}
        <div className="pt-4">
          <SectionHeader icon={<BookOpen className="w-5 h-5" />} title="איך לחשוב בשיעורי בית הזה" color="text-indigo-700" />
          <div className="bg-indigo-50 rounded-lg p-4">
            {hw.mindset.map((line, i) => (
              <p key={i} className="text-sm text-indigo-900 mb-1 last:mb-0">{line}</p>
            ))}
          </div>
        </div>

        {/* 2. Golden Rules */}
        <div>
          <SectionHeader icon={<Target className="w-5 h-5" />} title="כללי זהב" color="text-amber-700" />
          <div className="bg-amber-50 rounded-lg p-4">
            <RuleList items={hw.goldenRules} color="bg-amber-500" />
          </div>
        </div>

        {/* 3. Identification */}
        <div>
          <SectionHeader icon={<Search className="w-5 h-5" />} title="זיהוי סוג השאלה — איך מזהים?" color="text-blue-700" />
          <div className="space-y-3">
            {hw.identification.map((item, i) => (
              <div key={i} className="bg-blue-50 rounded-lg p-4">
                <div className="font-semibold text-blue-900 text-sm mb-2">{item.type}</div>
                <ul className="space-y-1">
                  {item.signals.map((sig, j) => (
                    <li key={j} className="text-sm text-blue-800 flex gap-2">
                      <span className="text-blue-400">&#8226;</span>{sig}
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>

        {/* 4. Strategies */}
        <div>
          <SectionHeader icon={<ListChecks className="w-5 h-5" />} title="אסטרטגיות פתרון — שלב אחרי שלב" color="text-green-700" />
          <div className="space-y-3">
            {hw.strategies.map((strat, i) => (
              <div key={i} className="bg-green-50 rounded-lg p-4">
                <div className="font-semibold text-green-900 text-sm mb-2">{strat.name}</div>
                <ol className="space-y-1">
                  {strat.steps.map((step, j) => (
                    <li key={j} className="text-sm text-green-800">{step}</li>
                  ))}
                </ol>
              </div>
            ))}
          </div>
        </div>

        {/* 5. Traps */}
        <div>
          <SectionHeader icon={<ShieldAlert className="w-5 h-5" />} title="מלכודות נפוצות ואינטואיציות שגויות" color="text-red-700" />
          <div className="space-y-3">
            {hw.traps.map((trap, i) => (
              <div key={i} className="bg-red-50 rounded-lg p-4">
                <div className="font-semibold text-red-900 text-sm mb-1">{trap.trap}</div>
                <div className="text-sm text-red-700 mb-1"><span className="font-medium">מה חושבים:</span> {trap.wrong}</div>
                <div className="text-sm text-green-700"><span className="font-medium">מה נכון:</span> {trap.right}</div>
              </div>
            ))}
          </div>
        </div>

        {/* 6. Shortcuts */}
        <div>
          <SectionHeader icon={<Rocket className="w-5 h-5" />} title="קיצורי דרך למבחן" color="text-purple-700" />
          <div className="bg-purple-50 rounded-lg p-4">
            <RuleList items={hw.shortcuts} color="bg-purple-500" />
          </div>
        </div>

        {/* 7. Cheat Sheet */}
        <div>
          <SectionHeader icon={<Zap className="w-5 h-5" />} title="דף סיכום אולטרה-קצר" color="text-orange-700" />
          <div className="bg-gray-900 rounded-lg p-4">
            <div className="space-y-1">
              {hw.cheatSheet.map((line, i) => (
                <div key={i} className="text-sm text-green-400 font-mono">{line}</div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
